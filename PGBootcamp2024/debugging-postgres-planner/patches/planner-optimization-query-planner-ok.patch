diff --git a/src/backend/optimizer/plan/planmain.c b/src/backend/optimizer/plan/planmain.c
index 7afd434c60..eb1092bb84 100644
--- a/src/backend/optimizer/plan/planmain.c
+++ b/src/backend/optimizer/plan/planmain.c
@@ -272,6 +272,8 @@ query_planner(PlannerInfo *root,
 	 */
 	distribute_row_identity_vars(root);
 
+	clamp_range_qualifiers(root);
+
 	/*
 	 * Ready to do the primary planning.
 	 */
diff --git a/src/backend/optimizer/util/clauses.c b/src/backend/optimizer/util/clauses.c
index 62650995cb..4c6ed81083 100644
--- a/src/backend/optimizer/util/clauses.c
+++ b/src/backend/optimizer/util/clauses.c
@@ -40,6 +40,7 @@
 #include "optimizer/optimizer.h"
 #include "optimizer/plancat.h"
 #include "optimizer/planmain.h"
+#include "optimizer/restrictinfo.h"
 #include "parser/analyze.h"
 #include "parser/parse_agg.h"
 #include "parser/parse_coerce.h"
@@ -5409,3 +5410,104 @@ pull_paramids_walker(Node *node, Bitmapset **context)
 	return expression_tree_walker(node, pull_paramids_walker,
 								  (void *) context);
 }
+
+static bool
+extract_const_compare_expression(OpExpr *expr, Var **out_var, Const **out_const)
+{
+	List *args = expr->args;
+	if (list_length(args) != 2)
+	{
+		return false;
+	}
+	if (!IsA(linitial(args), Var))
+	{
+		return false;
+	}
+	*out_var = (Var *)linitial(args);
+	if (!IsA(llast(args), Const))
+	{
+		return false;
+	}
+	*out_const = (Const *)llast(args);
+	return true;
+}
+
+static bool
+is_exclusive_range(OpExpr *left, OpExpr *right)
+{
+	Var *left_var;
+	Const *left_const;
+	Var *right_var;
+	Const *right_const;
+
+	if (!extract_const_compare_expression(left, &left_var, &left_const))
+	{
+		return false;
+	}
+	if (!extract_const_compare_expression(right, &right_var, &right_const))
+	{
+		return false;
+	}
+	if (!equal(left_var, right_var))
+	{
+		return false;
+	}
+
+	if (!equal(left_const, right_const))
+	{
+		return false;
+	}
+
+	return get_negator(left->opno) == right->opno;
+}
+
+static void
+clamp_range_qualifier_for_rel(PlannerInfo *root, RelOptInfo *rel)
+{
+	ListCell *lc;
+	RestrictInfo *prev_rinfo;
+
+	if (list_length(rel->baserestrictinfo) < 2)
+	{
+		return;
+	}
+
+	prev_rinfo = linitial(rel->baserestrictinfo);
+
+	for_each_from(lc, rel->baserestrictinfo, 1)
+	{
+		RestrictInfo *cur_rinfo = (RestrictInfo *)lfirst(lc);
+		if (IsA(prev_rinfo->clause, OpExpr) && IsA(cur_rinfo->clause, OpExpr) &&
+			is_exclusive_range((OpExpr *)prev_rinfo->clause, (OpExpr *)cur_rinfo->clause))
+		{
+			RestrictInfo *false_rinfo = make_restrictinfo(root,
+														  (Expr *)makeBoolConst(false, false),
+														  false,
+														  false,
+														  false,
+														  false,
+														  0,
+														  NULL, NULL, NULL);
+			rel->baserestrictinfo = list_make1(false_rinfo);
+			return;
+		}
+		else
+		{
+			prev_rinfo = cur_rinfo;
+		}
+	}
+}
+
+void clamp_range_qualifiers(PlannerInfo *root)
+{
+	for (size_t i = 1; i < root->simple_rel_array_size; i++)
+	{
+		RelOptInfo *rel = root->simple_rel_array[i];
+		if (rel == NULL || rel->rtekind != RTE_RELATION)
+		{
+			continue;
+		}
+
+		clamp_range_qualifier_for_rel(root, rel);
+	}
+}
diff --git a/src/backend/optimizer/util/plancat.c b/src/backend/optimizer/util/plancat.c
index 1a3045479f..9ca7ce1065 100644
--- a/src/backend/optimizer/util/plancat.c
+++ b/src/backend/optimizer/util/plancat.c
@@ -31,6 +31,7 @@
 #include "catalog/pg_proc.h"
 #include "catalog/pg_statistic_ext.h"
 #include "catalog/pg_statistic_ext_data.h"
+#include "catalog/pg_operator.h"
 #include "foreign/fdwapi.h"
 #include "miscadmin.h"
 #include "nodes/makefuncs.h"
@@ -54,6 +55,7 @@
 #include "utils/rel.h"
 #include "utils/snapmgr.h"
 #include "utils/syscache.h"
+#include "utils/datum.h"
 
 /* GUC parameter */
 int			constraint_exclusion = CONSTRAINT_EXCLUSION_PARTITION;
@@ -1533,6 +1535,83 @@ get_relation_statistics(RelOptInfo *rel, Relation relation)
 	return stainfos;
 }
 
+static bool extract_const_compare_expression(OpExpr *expr, Var **out_var, Const **out_const)
+{
+	List *args = expr->args;
+	if (list_length(args) != 2)
+	{
+		return false;
+	}
+
+	if (!IsA(linitial(args), Var))
+	{
+		return false;
+	}
+	*out_var = (Var *)linitial(args);
+
+	if (!IsA(llast(args), Const))
+	{
+		return false;
+	}
+	*out_const = (Const *)llast(args);
+
+	return true;
+}
+
+static bool use_negate_operators(OpExpr *left, OpExpr *right)
+{
+	HeapTuple left_tup, right_tup;
+	Oid left_negator, right_negator;
+
+	left_tup = SearchSysCache1(OPEROID, ObjectIdGetDatum(left->opno));
+	right_tup = SearchSysCache1(OPEROID, ObjectIdGetDatum(right->opno));
+
+	left_negator = ((Form_pg_operator)GETSTRUCT(left_tup))->oprnegate;
+	right_negator = ((Form_pg_operator)GETSTRUCT(right_tup))->oprnegate;
+
+	ReleaseSysCache(left_tup);
+	ReleaseSysCache(right_tup);
+
+	return left->opno == right_negator || right->opno == left_negator;
+}
+
+static bool is_exclusive_range(OpExpr *left, OpExpr *right)
+{
+	Var *left_var;
+	Const *left_const;
+	Var *right_var;
+	Const *right_const;
+
+	if (!use_negate_operators(left, right))
+	{
+		return false;
+	}
+
+	if (!extract_const_compare_expression(left, &left_var, &left_const))
+	{
+		return false;
+	}
+
+	if (!extract_const_compare_expression(right, &right_var, &right_const))
+	{
+		return false;
+	}
+
+	if (!(left_var->varno == right_var->varno &&
+		  left_var->varattno == right_var->varattno))
+	{
+		return false;
+	}
+
+	if (!datumIsEqual(left_const->constvalue, right_const->constvalue,
+					  right_const->constbyval, right_const->constlen))
+	{
+		return false;
+	}
+
+	return true;
+}
+
 /*
  * relation_excluded_by_constraints
  *
diff --git a/src/include/optimizer/optimizer.h b/src/include/optimizer/optimizer.h
index e7a557ef7b..df1c858c0c 100644
--- a/src/include/optimizer/optimizer.h
+++ b/src/include/optimizer/optimizer.h
@@ -200,5 +200,6 @@ extern bool contain_vars_of_level(Node *node, int levelsup);
 extern int	locate_var_of_level(Node *node, int levelsup);
 extern List *pull_var_clause(Node *node, int flags);
 extern Node *flatten_join_alias_vars(PlannerInfo *root, Query *query, Node *node);
+extern void clamp_range_qualifiers(PlannerInfo *root);
 
 #endif							/* OPTIMIZER_H */
