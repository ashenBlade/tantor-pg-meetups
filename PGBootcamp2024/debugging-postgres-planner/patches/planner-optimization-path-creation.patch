diff --git a/src/backend/optimizer/path/allpaths.c b/src/backend/optimizer/path/allpaths.c
index f75e0f99cb..cf023dc70e 100644
--- a/src/backend/optimizer/path/allpaths.c
+++ b/src/backend/optimizer/path/allpaths.c
@@ -50,6 +50,8 @@
 #include "port/pg_bitutils.h"
 #include "rewrite/rewriteManip.h"
 #include "utils/lsyscache.h"
+#include "utils/syscache.h"
+#include "utils/datum.h"
 
 
 /* Bitmask flags for pushdown_safety_info.unsafeFlags */
@@ -355,6 +357,99 @@ set_base_rel_pathlists(PlannerInfo *root)
 	}
 }
 
+static bool
+extract_operator_const_comp_expression(OpExpr *expr, Var **out_var, Const **out_const)
+{
+	List *args = expr->args;
+	if (list_length(args) != 2)
+	{
+		return false;
+	}
+	if (!IsA(linitial(args), Var))
+	{
+		return false;
+	}
+	*out_var = (Var *)linitial(args);
+	if (!IsA(llast(args), Const))
+	{
+		return false;
+	}
+	*out_const = (Const *)llast(args);
+	return true;
+}
+
+static bool
+is_mutually_exclusive(OpExpr *left, OpExpr *right)
+{
+	Var *left_var;
+	Const *left_const;
+	Var *right_var;
+	Const *right_const;
+
+	if (!extract_operator_const_comp_expression(left, &left_var, &left_const))
+	{
+		return false;
+	}
+	if (!extract_operator_const_comp_expression(right, &right_var, &right_const))
+	{
+		return false;
+	}
+
+	if (!equal(left_var, right_var))
+	{
+		return false;
+	}
+	if (!equal(left_const, right_const))
+	{
+		return false;
+	}
+
+	return get_negator(left->opno) == right->opno ||
+		left->opno == get_negator(right->opno);
+}
+
+static bool
+relation_excluded_by_restrictions(PlannerInfo *root, RelOptInfo *rel,
+								  RangeTblEntry *rte)
+{
+	RestrictInfo *prev_rinfo;
+	ListCell *lc;
+
+	if (rte->rtekind != RTE_RELATION)
+	{
+		return false;
+	}
+
+	if (list_length(rel->baserestrictinfo) < 2)
+	{
+		return false;
+	}
+
+	prev_rinfo = NULL;
+
+	foreach (lc, rel->baserestrictinfo)
+	{
+		RestrictInfo *cur_rinfo = (RestrictInfo *)lfirst(lc);
+		if (prev_rinfo == NULL)
+		{
+			prev_rinfo = cur_rinfo;
+			continue;
+		}
+
+		if (IsA(prev_rinfo->clause, OpExpr) && IsA(cur_rinfo->clause, OpExpr) &&
+			is_mutually_exclusive((OpExpr *)prev_rinfo->clause, (OpExpr *)cur_rinfo->clause))
+		{
+			return true;
+		}
+		else
+		{
+			prev_rinfo = cur_rinfo;
+		}
+	}
+
+	return false;
+}
+
 /*
  * set_rel_size
  *	  Set size estimates for a base relation
@@ -364,7 +459,8 @@ set_rel_size(PlannerInfo *root, RelOptInfo *rel,
 			 Index rti, RangeTblEntry *rte)
 {
 	if (rel->reloptkind == RELOPT_BASEREL &&
-		relation_excluded_by_constraints(root, rel, rte))
+		(relation_excluded_by_constraints(root, rel, rte) ||
+		 relation_excluded_by_restrictions(root, rel, rte)))
 	{
 		/*
 		 * We proved we don't need to scan the rel via constraint exclusion,
