diff --git a/src/backend/optimizer/util/clauses.c b/src/backend/optimizer/util/clauses.c
index b4e085e9d4..3ab65a3daf 100644
--- a/src/backend/optimizer/util/clauses.c
+++ b/src/backend/optimizer/util/clauses.c
@@ -3861,6 +3861,62 @@ simplify_or_arguments(List *args,
 	return newargs;
 }
 
+static
+bool extract_operator_const_comp_expression(OpExpr *expr, Var **out_var, Const **out_const)
+{
+	List *args = expr->args;
+	if (list_length(args) != 2)
+	{
+		return false;
+	}
+
+	if (!IsA(linitial(args), Var))
+	{
+		return false;
+	}
+	*out_var = (Var*) linitial(args);
+
+	if (!IsA(llast(args), Const))
+	{
+		return false;
+	}
+	*out_const = (Const *)llast(args);
+
+	return true;
+}
+
+static
+bool is_mutually_exclusive(OpExpr *left, OpExpr *right)
+{
+	Var *left_var;
+	Const *left_const;
+	Var *right_var;
+	Const *right_const;
+
+	if (!extract_operator_const_comp_expression(left, &left_var, &left_const))
+	{
+		return false;
+	}
+
+	if (!extract_operator_const_comp_expression(right, &right_var, &right_const))
+	{
+		return false;
+	}
+
+	if (!equal(left_var, right_var))
+	{
+		return false;
+	}
+
+	if (!equal(left_const, right_const))
+	{
+		return false;
+	}
+
+	return get_negator(left->opno) == right->opno ||
+		   left->opno == get_negator(right->opno);
+}
+
 /*
  * Subroutine for eval_const_expressions: process arguments of an AND clause
  *
@@ -3950,6 +4006,15 @@ simplify_and_arguments(List *args,
 			continue;
 		}
 
+		if (IsA(arg, OpExpr) && list_length(newargs) > 0 && IsA(llast(newargs), OpExpr))
+		{
+			if (is_mutually_exclusive((OpExpr *)arg, (OpExpr *)llast(newargs)))
+			{
+				*forceFalse = true;
+				return NIL;
+			}
+		}
+
 		/* else emit the simplified arg into the result list */
 		newargs = lappend(newargs, arg);
 	}
