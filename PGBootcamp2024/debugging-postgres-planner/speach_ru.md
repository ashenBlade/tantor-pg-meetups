# Отлаживаем планировщик Postgres

## Высокоуровневая архитектура планировщика

### Процесс выполнения запроса (парсер -> планировщик -> исполнитель)

В начале вспомним процесс обработки запроса. Этот процесс можно представить в
виде 3 этапов:

1. Парсинг запроса
2. Работа планировщика
3. Исполнение запроса
 
Сегодня поговорим именно о 2 этапе – работе планировщика.

### Устройство планировщика: оптимизация запроса, создание возможных путей

выполнения, создание плана запроса

Рассмотрим общий вид на то, как работает планировщик. 
Его работу можно поделить на несколько (TODO: конкретное число) этапов:

1. Предобработка дерева запроса
2. Оптимизация
3. Нахождение возможных путей выполнения
4. Выбор наиболее оптимального плана выполнения

Первые 2 этапа – это оптимизации. Разница заключается в том, что в 1 этапе мы
работаем только с деревом запроса и выполняем простые оптимизации, например,
constant folding (вычисляем выражения с константными значениями). А во 2 этапе
применяются уже более сложные оптимизации. Как правило они связаны со знаниями
о всем запросе (join'ы, TODO: добавить)

3 этап – мы находим все возможные пути выполнения запроса, используя знания
полученные после всех оптимизаций.

Последний 4 этап – строим план выполнения из самого дешевого пути.

### Как это организовано в исходном коде: функции, как можно разграничить

Говоря об исходном коде, это организовано следующим образом.

- `query_planner` – планировщик для создания путей доступа к самим таблицам,
    т.е. создает узлы Scan методов (SeqScan, IndexScan и т.д.)
- `grouping_planner` – обертка над `query_planner`, ответственная за добавление
    логики постобработки кортежей (сортировка, группировка). Грубо говоря,
    декорирует узлы чтения нужной логикой
- `subquery_planner` – входная точка для планирования 1 запроса: подготавливает
    запрос для `grouping_planner` и вызывает его
- `standard_planner` – входная точка самого планировщика

Схематично, это можно отобразить так.

На самом верху имеется `standard_planner`. Он подготавливает окружение и после
вызывает `subquery_planner` для самого высокоуровнего запроса.

`subquery_planner`: предобрабатывает *дерево запроса* и вызывает
`grouping_planner` для анализа всего запроса, а после создает план для самого
дешевого пути.

`grouping_planner`: отвечает за логику обработки прочитанных кортежей:
сортировка, группировка, оконные функции и т.д.

`query_planner`: инициализирует состояние планировщика и находит возможные
методы доступа к таблице.

TODO: схема с кодом

```c
standard_planner()
{
    subquery_planner()
    {
        /* Parse Tree preprocessing */
        groui
    }
}
```

## Используемые типы данных (структуры)

### Введение в узлы: что это, в каких файлах определяются

### Разбор Node типов: тэги, особные типы (Bitmapset, List)

### Основные типы для планировщика: PlannerInfo, PlannerGlobal, Parse и т.д.

## Делаем свою оптимизацию
### Постановка задачи

### Проектируем решение: дерево выражений, какие типы нод нам нужны, какие поля нужно посмотреть и т.д.

### Лайвкодинг: пишем первую версию, находим недостаток, делаем исправление

### Подводим итоги: что сделали, как сделали (закрепляем материал)

## Советы как упростить себе жизнь при отладке
 
 - `.psqlrc` - чтобы pid бэкэнда выводился
 - Параметры конфигурации для отображения плана `debug_print_plan`, `debug_print_rewritten` и т.д.
 - таски для vscode - автоматизация рутинных действий (сборка, запуск БД, psql) с примерами скриптов
 - Настройка C/C++ расширения - конфиг файл с include, настройкой версии и т.д.
 - Мое расширение PostgreSQL Hacker Helper (опишу во всех подробностях)

