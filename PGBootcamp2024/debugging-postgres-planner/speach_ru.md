# Отлаживаем планировщик Postgres

## Высокоуровневая архитектура планировщика

### Процесс выполнения запроса (парсер -> планировщик -> исполнитель)

В начале вспомним процесс обработки запроса. Этот процесс можно представить в
виде 3 этапов:

1. Парсинг запроса
2. Работа планировщика
3. Исполнение запроса

Сегодня поговорим именно о 2 этапе – работе планировщика.

### Устройство планировщика: оптимизация запроса, создание возможных путей

выполнения, создание плана запроса

Рассмотрим общий вид на то, как работает планировщик.
Его работу можно поделить на несколько (TODO: конкретное число) этапов:

1. Предобработка дерева запроса
2. Оптимизация
3. Нахождение возможных путей выполнения
4. Выбор наиболее оптимального плана выполнения

Первые 2 этапа – это оптимизации. Разница заключается в том, что в 1 этапе мы
работаем только с деревом запроса и выполняем простые оптимизации, например,
constant folding (вычисляем выражения с константными значениями). А во 2 этапе
применяются уже более сложные оптимизации. Как правило они связаны со знаниями
о всем запросе (join'ы, TODO: добавить)

3 этап – мы находим все возможные пути выполнения запроса, используя знания
полученные после всех оптимизаций.

Последний 4 этап – строим план выполнения из самого дешевого пути.

### Как это организовано в исходном коде: функции, как можно разграничить

Говоря об исходном коде, это организовано следующим образом.

- `query_planner` – планировщик для создания путей доступа к самим таблицам,
    т.е. создает узлы Scan методов (SeqScan, IndexScan и т.д.)
- `grouping_planner` – обертка над `query_planner`, ответственная за добавление
    логики постобработки кортежей (сортировка, группировка). Грубо говоря,
    декорирует узлы чтения нужной логикой
- `subquery_planner` – входная точка для планирования 1 запроса: подготавливает
    запрос для `grouping_planner` и вызывает его
- `standard_planner` – входная точка самого планировщика

Схематично, это можно отобразить так.

На самом верху имеется `standard_planner`. Он подготавливает окружение и после
вызывает `subquery_planner` для самого высокоуровнего запроса.

`subquery_planner`: предобрабатывает *дерево запроса* и вызывает
`grouping_planner` для анализа всего запроса, а после создает план для самого
дешевого пути.

`grouping_planner`: отвечает за логику обработки прочитанных кортежей:
сортировка, группировка, оконные функции и т.д.

`query_planner`: инициализирует состояние планировщика и находит возможные
методы доступа к таблице.

```c
standard_planner()
{
    /* Initialize global state */
    subquery_planner()
    {
        /* Parse tree preprocessing */
        grouping_planner()
        {
            /* Setup grouping operations support */
            query_planner()
            {
                /* Setup planner info */
                /* Create Scan path */
            }
            /* Decorate with sort/agg/window/... paths */
        }
        /* Select cheapest path */
    }
    /* Create plan for whole query */
}
```

`subquery_planner` - запускается для каждого обнаруженного подзапроса, причем
верхнеуровневый запрос - тоже подзапрос, просто у него не родителя.

TODO: схема с запросом и какая часть за что отвечает

## Используемые типы данных (структуры)

Теперь поговорим о структурах данных.

### Введение в узлы: что это, в каких файлах определяются

Многие структуры данных в Postgres являются узлами - `Node`. Первое поле у
каждого узла - это тэг, `NodeTag`. Тэг - это простой enum, составляется он
как префикс `T_` + название типа.

Все возможные узлы уже известны и их значения определяются в `src/include/nodes/node.h`,
либо, начиная с 16 версии автоматически генерируются в `src/include/nodes/nodetags.h`.

### Разбор Node типов: тэги, особные типы (Bitmapset, List)

На этой схеме представлено дерево этих узлов. Все не уместились - их 474, поэтому
рассмотрим основные.

TODO: схема с узлами

`List` - это динамический массив. Хранить он может в себе `Node *`, `int`,
`Oid` или `TransactionId`, но только одного типа. Достигается это тем, что
у списка есть отдельный тэг для каждого типа:

| Тип             | Тэг         |
| --------------- | ----------- |
| `Node *`        | `T_List`    |
| `int`           | `T_IntList` |
| `Oid`           | `T_OidList` |
| `TransactionId` | `T_XidList` |

Но при этом, название типа одно и то же - `List`.

`Bitmapset` - это множество чисел.

`Expr` - это базовый тип для узлов, которые могут быть выполнены. Примеры:

| Тип        | Описание             | Результат выполнения             |
| ---------- | -------------------- | -------------------------------- |
| `Var`      | Атрибут таблицы      | Значение атрибута из кортежа     |
| `Const`    | Константа            | Значение константы               |
| `OpExpr`   | Оператор             | Вызов оператора с аргументами    |
| `FuncExpr` | Функция              | Вызор функции с аргументами      |
| `BoolExpr` | Логическое выражение | Выполнение логического выражения |
| `SubPlan`  | Подзапрос            | Результат запроса                |

> `Node` и `Expr` - это псевдоузлы, в том понимании, что у них нет своего тэга.
> Они служат только маркерами: `Node` - это узел, `Expr` - это вычисляемый узел.

### Основные типы для планировщика

Теперь поговорим о представлении запроса в коде.

Весь запрос - это множество подзапросов. Даже если их нет, то весь запрос - это
один большой подзапрос.

`PlannerGlobal` - хранит информацию о всем запросе. Создается в самом начале -
`standard_planner`.

`PlannerInfo` - хранит информацию об одном подзапросе. Создается в `subquery_planner`.

На схеме изображено отношение между запросами и подзапросами.

TODO: схема

Дальше поговорим об источнике данных.

Грубо говоря, все, что находится во `FROM` - это Range Table. Range Table - это
набор Range Table Entry:

- Таблица
- Функция
- Другой подзапрос
- `JOIN`'ы
- CTE
- `VALUES`

`RangeTblEntry` - это структура, представляющая Range Table Entry.

На схеме изображены RTE, участвующие во `FROM`:

TODO: схема

`RelOptInfo` - это структура планировщика для RTE. Можно сказать, разница в том, что
`RangeTblEntry` больше про дерево запроса, а `RelOptInfo` - про планировщик.
Например, хранит в себе количество страниц или кортежей, стоимость путей.

`RestrictInfo` - представляет ограничение. Это может быть не только условие в
`WHERE`, но и условие `JOIN`, либо ограничения таблицы (`CONSTRAINT`).

## Делаем свою оптимизацию

Constraint Exclusion - это оптимизация, которая учитывает наложенные ограничения:
на запрос, на таблицу, на значения и т.д.

Предлагаю реализовать нечто подобное в Postgres.

### Постановка задачи

Для конкретики - мы хотим учитывать допустимый диапазон возможных значений.
Например, если в `WHERE` имеется `AND` со сравнениями атрибутов, то этот атрибут
не может быть одновременно больше и не больше определенной константы. Вот этим
и займемся.

### Проектируем решение: дерево выражений, какие типы нод нам нужны, какие поля нужно посмотреть и т.д.

Для начала отобразим, то что мы хотим получить. Говоря в терминах узлов, такую
ситуацию можно определить следующим шаблоном.

TODO: схема OpExpr->Var->Const

Таким образом мы ищем `AND`, у которого оба выражения - вызовы оператора, имеющие
разные только операторы (противоположные).Если мы обнаружили такой паттерн, то
можем сказать, что этот запрос можно убрать из рассмотрения - он ничего не вернет.

В примере, это численное сравнение - никакое число не может быть одновременно
и больше и не больше 0.

Для простоты будем искать только их - без `OR`, `NOT`, обнаружения перестановок
узлов и прочего. Только `AND`, атрибуты и константы.

### Лайвкодинг: пишем первую версию, находим недостаток, делаем исправление

Для начала спроектируем базовую функцию - определение взаимоисключающих условий.
Тут нам понадобится знание об узлах.

Эта функция будет принимать на вход 2 `OpExpr` и возвращать `true`, если это
взаимоисключающие условия.

Первым делом определим, что по обе стороны оператора - атрибут и константа.
Операнд в Postgres - это тоже функция и у нее есть свои аргументы. Они хранятся
в списке `Args`.

Длина этого списка должна быть равна 2, так как мы ищем операторы сравнения.
Причем, первый аргумент - атрибут, а второй - константа. Атрибут выражается
узлом `Var`, а константа `Const`.

Для проверки тэга узла используется макрос `IsA(nodeptr, type)`.

Проверку и получение `Var` и `Const` вынесем в отдельную функцию:

```c
static bool
extract_const_compare_expression(OpExpr *expr, Var **out_var, Const **out_const)
{
    List *args = expr->args;
    /* Check exactly 2 operands */
    if (list_length(args) != 2)
    {
        return false;
    }
    /* First element - attribute */
    if (!IsA(linitial(args), Var))
    {
        return false;
    }
    *out_var = (Var *) linitial(args);

    /* Second element - constant */
    if (!IsA(llast(args), Const))
    {
        return false;
    }
    *out_const = (Const *) llast(args);
    return true;
}
```

Теперь для каждого из выражений необходимо проверить, что соответствующие операнды
равны. Для их сравнения можно воспользоваться функцией `equal`. На вход она
принимает 2 `void` указателя, но на самом деле работает с указателями на `Node`.

Последний этап - проверка операндов. Мы воспользуемся `pg_operator`. В заголовочном
файле `utils/cache/lsyscache.c` находится множество полезных и часто используемых
функций для работы с системным каталогом. Нас интересует функция `get_negator` -
она по переданному `Oid` оператора возвращает `Oid` соответствующего ему
противоположного оператора. Для `<` это `<=`.

В результате, функция выглядит таким образом:

```c
static bool
is_mutually_exclusive(OpExpr *left, OpExpr *right)
{
    Var *left_var;
    Const *left_const;
    Var *right_var;
    Const *right_const;

    /* Extract operands */
    if (!extract_const_compare_expression(left, &left_var, &left_const))
    {
        return false;
    }
    if (!extract_const_compare_expression(right, &right_var, &right_const))
    {
        return false;
    }
    
    /* Attributes equal */
    if (!equal(left_var, right_var))
    {
        return false;
    }
    
    /* Constants equal */
    if (!equal(left_const, right_const))
    {
        return false;
    }

    /* Operators are opposite  */
    return get_negator(left->opno) == right->opno || 
           left->opno == get_negator(right->opno);
}

```

### Подводим итоги: что сделали, как сделали (закрепляем материал)

## Советы как упростить себе жизнь при отладке
 
 - `.psqlrc` - чтобы pid бэкэнда выводился
 - Параметры конфигурации для отображения плана `debug_print_plan`, `debug_print_rewritten` и т.д.
 - таски для vscode - автоматизация рутинных действий (сборка, запуск БД, psql) с примерами скриптов
 - Настройка C/C++ расширения - конфиг файл с include, настройкой версии и т.д.
 - Мое расширение PostgreSQL Hacker Helper (опишу во всех подробностях)

