# Отлаживаем планировщик Postgres

## Высокоуровневая архитектура планировщика

### Процесс выполнения запроса (парсер -> планировщик -> исполнитель)

В начале вспомним процесс обработки запроса. Этот процесс можно представить в
виде 3 этапов:

1. Парсинг запроса
2. Работа планировщика
3. Исполнение запроса

Сегодня поговорим именно о 2 этапе – работе планировщика.

### Устройство планировщика: оптимизация запроса, создание возможных путей

выполнения, создание плана запроса

Рассмотрим общий вид на то, как работает планировщик.
Его работу можно поделить на несколько (TODO: конкретное число) этапов:

1. Предобработка дерева запроса
2. Оптимизация
3. Нахождение возможных путей выполнения
4. Выбор наиболее оптимального плана выполнения

Первые 2 этапа – это оптимизации. Разница заключается в том, что в 1 этапе мы
работаем только с деревом запроса и выполняем простые оптимизации, например,
constant folding (вычисляем выражения с константными значениями). А во 2 этапе
применяются уже более сложные оптимизации. Как правило они связаны со знаниями
о всем запросе (join'ы, TODO: добавить)

3 этап – мы находим все возможные пути выполнения запроса, используя знания
полученные после всех оптимизаций.

Последний 4 этап – строим план выполнения из самого дешевого пути.

### Как это организовано в исходном коде: функции, как можно разграничить

Говоря об исходном коде, это организовано следующим образом.

- `query_planner` – планировщик для создания путей доступа к самим таблицам,
    т.е. создает узлы Scan методов (SeqScan, IndexScan и т.д.)
- `grouping_planner` – обертка над `query_planner`, ответственная за добавление
    логики постобработки кортежей (сортировка, группировка). Грубо говоря,
    декорирует узлы чтения нужной логикой
- `subquery_planner` – входная точка для планирования 1 запроса: подготавливает
    запрос для `grouping_planner` и вызывает его
- `standard_planner` – входная точка самого планировщика

Схематично, это можно отобразить так.

На самом верху имеется `standard_planner`. Он подготавливает окружение и после
вызывает `subquery_planner` для самого высокоуровнего запроса.

`subquery_planner`: предобрабатывает *дерево запроса* и вызывает
`grouping_planner` для анализа всего запроса, а после создает план для самого
дешевого пути.

`grouping_planner`: отвечает за логику обработки прочитанных кортежей:
сортировка, группировка, оконные функции и т.д.

`query_planner`: инициализирует состояние планировщика и находит возможные
методы доступа к таблице.

```c
standard_planner()
{
    /* Initialize global state */
    subquery_planner()
    {
        /* Parse tree preprocessing */
        grouping_planner()
        {
            /* Setup grouping operations support */
            query_planner()
            {
                /* Setup planner info */
                /* Create Scan path */
            }
            /* Decorate with sort/agg/window/... paths */
        }
        /* Select cheapest path */
    }
    /* Create plan for whole query */
}
```

`subquery_planner` - запускается для каждого обнаруженного подзапроса, причем
верхнеуровневый запрос - тоже подзапрос, просто у него не родителя.

TODO: схема с запросом и какая часть за что отвечает

## Используемые типы данных (структуры)

Теперь поговорим о структурах данных.

### Введение в узлы: что это, в каких файлах определяются

Многие структуры данных в Postgres являются узлами - `Node`. Первое поле у
каждого узла - это тэг, `NodeTag`. Тэг - это простой enum, составляется он
как префикс `T_` + название типа.

Все возможные узлы уже известны и их значения определяются в `src/include/nodes/node.h`,
либо, начиная с 16 версии автоматически генерируются в `src/include/nodes/nodetags.h`.

### Разбор Node типов: тэги, особные типы (Bitmapset, List)

На этой схеме представлено дерево этих узлов. Все не уместились - их 474, поэтому
рассмотрим основные.

TODO: схема с узлами

`List` - это динамический массив. Хранить он может в себе `Node *`, `int`,
`Oid` или `TransactionId`, но только одного типа. Достигается это тем, что
у списка есть отдельный тэг для каждого типа:

| Тип             | Тэг         |
| --------------- | ----------- |
| `Node *`        | `T_List`    |
| `int`           | `T_IntList` |
| `Oid`           | `T_OidList` |
| `TransactionId` | `T_XidList` |

Но при этом, название типа одно и то же - `List`.

`Bitmapset` - это множество чисел.

`Expr` - это базовый тип для узлов, которые могут быть выполнены. Примеры:

| Тип        | Описание             | Результат выполнения             |
| ---------- | -------------------- | -------------------------------- |
| `Var`      | Атрибут таблицы      | Значение атрибута из кортежа     |
| `Const`    | Константа            | Значение константы               |
| `OpExpr`   | Оператор             | Вызов оператора с аргументами    |
| `FuncExpr` | Функция              | Вызор функции с аргументами      |
| `BoolExpr` | Логическое выражение | Выполнение логического выражения |
| `SubPlan`  | Подзапрос            | Результат запроса                |

### Основные типы для планировщика

Теперь поговорим о представлении запроса в коде.

Весь запрос - это множество подзапросов. Даже если их нет, то весь запрос - это
один большой подзапрос.

`PlannerGlobal` - хранит информацию о всем запросе. Создается в самом начале -
`standard_planner`.

`PlannerInfo` - хранит информацию об одном подзапросе. Создается в `subquery_planner`.

На схеме изображено отношение между запросами и подзапросами.

TODO: схема

Дальше поговорим об источнике данных.

Грубо говоря, все, что находится во `FROM` - это Range Table. Range Table - это
набор Range Table Entry:

- Таблица
- Функция
- Другой подзапрос
- `JOIN`'ы
- CTE
- `VALUES`

`RangeTblEntry` - это структура, представляющая Range Table Entry.

На схеме изображены RTE, участвующие во `FROM`:

TODO: схема

`RelOptInfo` - это структура планировщика для RTE. Можно сказать, разница в том, что
`RangeTblEntry` больше про дерево запроса, а `RelOptInfo` - про планировщик.
Например, хранит в себе количество страниц или кортежей, стоимость путей.

`RestrictInfo` - представляет ограничение. Это может быть не только условие в
`WHERE`, но и условие `JOIN`, либо ограничения таблицы (`CONSTRAINT`).

## Делаем свою оптимизацию

### Постановка задачи

### Проектируем решение: дерево выражений, какие типы нод нам нужны, какие поля нужно посмотреть и т.д.

### Лайвкодинг: пишем первую версию, находим недостаток, делаем исправление

### Подводим итоги: что сделали, как сделали (закрепляем материал)

## Советы как упростить себе жизнь при отладке
 
 - `.psqlrc` - чтобы pid бэкэнда выводился
 - Параметры конфигурации для отображения плана `debug_print_plan`, `debug_print_rewritten` и т.д.
 - таски для vscode - автоматизация рутинных действий (сборка, запуск БД, psql) с примерами скриптов
 - Настройка C/C++ расширения - конфиг файл с include, настройкой версии и т.д.
 - Мое расширение PostgreSQL Hacker Helper (опишу во всех подробностях)

